// Code generated by "go generate". DO NOT EDIT.

package watchable

import (
	"context"
	"sync"

	"github.com/golang/protobuf/proto"

	"github.com/datawire/telepresence2/pkg/rpc/manager"
)

// _InterceptMapUpdate describes a mutation made to a InterceptMap.
type _InterceptMapUpdate struct {
	Key string
	// Exactly one of either 'Value' or 'Delete' will be set.
	Value  *manager.InterceptInfo
	Delete bool
}

// InterceptMap is a wrapper around map[string]*manager.InterceptInfo (and around WatchableMap) that provides the
// additional features that:
//
// 1. it is thread-safe (via WatchableMap)
// 2. you can Subscribe to watch for updates (via WatchableMap)
// 3. you can Subscribe to just a subset of the map
// 4. it provides type safety beyond the abstract proto.Message interface (compared to WatchableMap,
//    which uses proto.Message similary to `interface{}`)
// 5. the Subscribe channel includes full snapshots, so you don't need to track the world (compared
//    to WatchableMap)
// 6. the Subscribe channel coalesces updates (compared to WatchableMap)
type InterceptMap struct {
	lock sync.RWMutex
	// things guarded by 'lock'
	close       chan struct{} // can read from the channel while unlocked, IF you've already validated it's non-nil
	value       map[string]*manager.InterceptInfo
	subscribers map[<-chan _InterceptMapUpdate]chan<- _InterceptMapUpdate // readEnd â†¦ writeEnd

	// not guarded by 'lock'
	wg sync.WaitGroup
}

func (tm *InterceptMap) unlockedInit() {
	if tm.close == nil {
		tm.close = make(chan struct{})
		tm.value = make(map[string]*manager.InterceptInfo)
		tm.subscribers = make(map[<-chan _InterceptMapUpdate]chan<- _InterceptMapUpdate)
	}
}

func (tm *InterceptMap) unlockedIsClosed() bool {
	select {
	case <-tm.close:
		return true
	default:
		return false
	}
}

// LoadAll returns a deepcopy of all key/value pairs in the map.
func (tm *InterceptMap) LoadAll() map[string]*manager.InterceptInfo {
	tm.lock.RLock()
	defer tm.lock.RUnlock()
	ret := make(map[string]*manager.InterceptInfo, len(tm.value))
	for k, v := range tm.value {
		ret[k] = proto.Clone(v).(*manager.InterceptInfo)
	}
	return ret
}

// Load returns a deepcopy of the value for a specific key.
func (tm *InterceptMap) Load(key string) (value *manager.InterceptInfo, ok bool) {
	tm.lock.RLock()
	defer tm.lock.RUnlock()
	ret, ok := tm.value[key]
	if !ok {
		return nil, false
	}
	return proto.Clone(ret).(*manager.InterceptInfo), true
}

// Store sets a key sets the value for a key.  This blocks forever if .Close() has already been
// called.
func (tm *InterceptMap) Store(key string, val *manager.InterceptInfo) {
	tm.lock.Lock()
	defer tm.lock.Unlock()

	tm.unlockedStore(key, val)
}

// LoadOrStore returns the existing value for the key if present.  Otherwise, it stores and returns
// the given value. The 'loaded' result is true if the value was loaded, false if stored.
//
// If the value does need to be stored, all the same blocking semantics as .Store() apply
func (tm *InterceptMap) LoadOrStore(key string, val *manager.InterceptInfo) (value *manager.InterceptInfo, loaded bool) {
	tm.lock.Lock()
	defer tm.lock.Unlock()

	loadedVal, loadedOK := tm.value[key]
	if loadedOK {
		return proto.Clone(loadedVal).(*manager.InterceptInfo), true
	}
	tm.unlockedStore(key, val)
	return proto.Clone(val).(*manager.InterceptInfo), false
}

func (tm *InterceptMap) unlockedStore(key string, val *manager.InterceptInfo) {
	tm.unlockedInit()
	if tm.unlockedIsClosed() {
		// block forever
		tm.lock.Unlock()
		select {}
	}

	tm.value[key] = val
	for _, subscriber := range tm.subscribers {
		subscriber <- _InterceptMapUpdate{
			Key:   key,
			Value: proto.Clone(val).(*manager.InterceptInfo),
		}
	}
}

// Delete deletes the value for a key.  This blocks forever if .Close() has already been called.
func (tm *InterceptMap) Delete(key string) {
	tm.lock.Lock()
	defer tm.lock.Unlock()

	tm.unlockedDelete(key)
}

func (tm *InterceptMap) unlockedDelete(key string) {
	tm.unlockedInit()
	if tm.unlockedIsClosed() {
		// block forever
		tm.lock.Unlock()
		select {}
	}

	if tm.value == nil {
		return
	}
	delete(tm.value, key)
	for _, subscriber := range tm.subscribers {
		subscriber <- _InterceptMapUpdate{
			Key:    key,
			Delete: true,
		}
	}
}

// LoadAndDelete deletes the value for a key, returning a deepcopy of the previous value if any.
// The 'loaded' result reports whether the key was present.
//
// If the value does need to be deleted, all the same blocking semantics as .Delete() apply.
func (tm *InterceptMap) LoadAndDelete(key string) (value *manager.InterceptInfo, loaded bool) {
	tm.lock.Lock()
	defer tm.lock.Unlock()

	loadedVal, loadedOK := tm.value[key]
	if !loadedOK {
		return nil, false
	}

	tm.unlockedDelete(key)

	return proto.Clone(loadedVal).(*manager.InterceptInfo), true
}

// Close marks the map as "finished", all subscriber channels are closed and further mutations are
// forbidden.
//
// After .Close() is called, any calls to .Store() will block forever, and any calls to .Subscribe()
// will return an already-closed channel.
//
// .Load() and .LoadAll() calls will continue to work normally after .Close() has been called.
func (tm *InterceptMap) Close() {
	tm.lock.Lock()

	tm.unlockedInit()
	if !tm.unlockedIsClosed() {
		close(tm.close)
	}
	tm.lock.Unlock()
	tm.wg.Wait()
}

// internalSubscribe returns a channel (that blocks on both ends), that is written to on each map
// update.  If the map is already Close()ed, then this returns nil.
func (tm *InterceptMap) internalSubscribe(ctx context.Context) <-chan _InterceptMapUpdate {
	tm.lock.Lock()
	defer tm.lock.Unlock()
	tm.unlockedInit()

	ret := make(chan _InterceptMapUpdate)
	if tm.unlockedIsClosed() {
		return nil
	}
	tm.subscribers[ret] = ret
	return ret
}

// Subscribe returns a channel that will emits a complete snapshot of the map immediately after the
// call to Subscribe(), and then whenever the map changes.  Updates are coalesced; if you do not
// need to worry about reading from the channel faster than you are able.  A read from the channel
// will block as long as there are no changes since the last read.
//
// The values in the snapshot are deepcopies of the actual values in the map, but values may be
// reused between snapshots; if you mutate a value in a snapshot, that mutation may erroneously
// persist in future snapshots.
//
// The returned channel will be closed when the Context is Done, or .Close() is called.  If .Close()
// has already been called, then an already-closed channel is returned.
func (tm *InterceptMap) Subscribe(ctx context.Context) <-chan map[string]*manager.InterceptInfo {
	return tm.SubscribeSubset(ctx, func(string, *manager.InterceptInfo) bool {
		return true
	})
}

// SubscribeSubset is like Subscribe, but the snapshot returned only includes entries that satisfy
// the 'include' predicate.  Mutations to entries that don't satisfy the predicate do not cause a
// new snapshot to be emitted.  If the value for a key changes from satisfying the predicate to not
// satisfying it, then this is treated as a delete operation, and a new snapshot is generated.
func (tm *InterceptMap) SubscribeSubset(ctx context.Context, include func(string, *manager.InterceptInfo) bool) <-chan map[string]*manager.InterceptInfo {
	upstream := tm.internalSubscribe(ctx)
	downstream := make(chan map[string]*manager.InterceptInfo)

	if upstream == nil {
		close(downstream)
		return downstream
	}

	tm.wg.Add(1)
	go tm.coalesce(ctx, include, upstream, downstream)

	return downstream
}

func (tm *InterceptMap) coalesce(
	ctx context.Context,
	includep func(string, *manager.InterceptInfo) bool,
	upstream <-chan _InterceptMapUpdate,
	downstream chan<- map[string]*manager.InterceptInfo,
) {
	defer tm.wg.Done()
	defer close(downstream)

	var shutdown func()
	shutdown = func() {
		shutdown = func() {}
		// Do this asyncrounously because getting the lock might block a .Store() that's
		// waiting on us to read from 'upstream'!  We don't need to worry about separately
		// waiting for this goroutine because we implicitly do that when we drain
		// 'upstream'.
		go func() {
			tm.lock.Lock()
			defer tm.lock.Unlock()
			close(tm.subscribers[upstream])
			delete(tm.subscribers, upstream)
		}()
	}

	// Cur is a snapshot of the current state all the map according to all _InterceptMapUpdates we've
	// received from 'upstream', with any entries removed that do not satisfy the predicate
	// 'includep'.
	cur := make(map[string]*manager.InterceptInfo)
	for k, v := range tm.LoadAll() {
		if includep(k, v) {
			cur[k] = v
		}
	}

	// curCopy is a copy of 'cur' that we send to the 'downstream' channel.  We don't send 'cur'
	// directly because we're nescessarily in a separate goroutine from the reader of
	// 'downstream', and map gets/sets aren't thread-safe, so we'd risk memory corruption with
	// our updating of 'cur' and the reader's accessing of 'cur'.  curCopy gets set to 'nil'
	// when we need to do a read before we can write to 'downstream' again.
	curCopy := make(map[string]*manager.InterceptInfo, len(cur))
	for k, v := range cur {
		curCopy[k] = v
	}

	// applyUpdate applies an update to 'cur', and updates 'curCopy' as nescessary.
	applyUpdate := func(update _InterceptMapUpdate) {
		if update.Delete || !includep(update.Key, update.Value) {
			if _, haveOld := cur[update.Key]; haveOld {
				delete(cur, update.Key)
				if curCopy != nil {
					delete(curCopy, update.Key)
				} else {
					curCopy = make(map[string]*manager.InterceptInfo, len(cur))
					for k, v := range cur {
						curCopy[k] = v
					}
				}
			}
		} else {
			if old, haveOld := cur[update.Key]; !haveOld || !proto.Equal(old, update.Value) {
				cur[update.Key] = update.Value
				if curCopy != nil {
					curCopy[update.Key] = update.Value
				} else {
					curCopy = make(map[string]*manager.InterceptInfo, len(cur))
					for k, v := range cur {
						curCopy[k] = v
					}
				}
			}
		}
	}

	for {
		if curCopy == nil {
			select {
			case <-ctx.Done():
				shutdown()
			case <-tm.close:
				shutdown()
			case update, readOK := <-upstream:
				if !readOK {
					return
				}
				applyUpdate(update)
			}
		} else {
			// Same as above, but with an additional "downstream <- curCopy" case.
			select {
			case <-ctx.Done():
				shutdown()
			case <-tm.close:
				shutdown()
			case update, readOK := <-upstream:
				if !readOK {
					return
				}
				applyUpdate(update)
			case downstream <- curCopy:
				curCopy = nil
			}
		}
	}
}
